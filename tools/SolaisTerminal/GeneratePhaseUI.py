import re
import argparse
from dataclasses import dataclass
from typing import Optional, List

HEAD = """/* Auto generated by GeneratePhaseUI.py written by liuzikai */

#ifndef UI_PHASES_H
#define UI_PHASES_H

#include <QtWidgets/QScrollArea>
#include <QtWidgets/QGroupBox>
#include <QtWidgets/QCheckBox>
#include <QtWidgets/QLabel>
#include <QtWidgets/QDoubleSpinBox>
#include <QtWidgets/QGridLayout>
#include <QtWidgets/QHBoxLayout>
#include <QtWidgets/QVBoxLayout>
#include "Parameters.pb.h"

namespace meta {

class PhaseController {
public:
"""

TAIL = """

    package::ParamSet getParamSet() const {
    
    }
    
    void applyParamSet(const package::ParamSet &p) {
    
    }

};

}

#endif  // UI_PHASES_H
"""


@dataclass
class Param:
    kind: str
    name: str
    label: str
    options: List[str] = ""


@dataclass
class Group:
    name: str
    params: List[Param]
    info_label: Optional[str] = None
    image: Optional[str] = None


def parse_groups(filename: str) -> [Group]:
    groups = {}
    enums = {}

    inside_message = None
    inside_enum = None
    current_group_name = None

    for line in open(filename, "r", encoding="utf-8"):

        line = line.strip()
        if line == "":
            continue

        if inside_message is None:
            if re.match(r"message +ParamSet +\{", line):
                inside_message = "ParamSet"
            elif re.match(r"message +Result +\{", line):
                inside_message = "Result"

        else:  # inside ParamSet or Result

            if inside_enum is not None:
                if line.startswith("}"):
                    inside_enum = None
                else:
                    if g := re.match(f"^(\S+?) *= *\d+ *;", line):
                        enums[inside_enum].append(g.group(1))
                    elif not line.startswith("//"):
                        raise ValueError(f'Unknown enum line "{line}"')

            else:  # not inside enum
                if g := re.match(r"^enum +(\S+?) *\{", line):
                    inside_enum = g.group(1)
                    enums[inside_enum] = []
                else:  # inside ParamSet or Result but not inside enum

                    if line.startswith("}"):
                        inside_message = None
                    else:
                        if g := re.match(f"^// *GROUP: *(\S+)$", line):
                            current_group_name = g.group(1)
                            if current_group_name not in groups.keys():
                                groups[current_group_name] = Group(name=current_group_name, params=[])
                        else:
                            if g := re.match(r"^(?:optional +)?(\S+?) +(\S+?) *= *\d+ *; *// *(.*) *", line):
                                kind = g.group(1)
                                if kind in enums.keys():
                                    # Add an enumeration parameter
                                    groups[current_group_name].params.append(
                                        Param(kind="Enum", name=g.group(2), label=g.group(3), options=enums[kind]))
                                elif kind == "string":
                                    # Result string
                                    assert inside_message == "Result", "string type appears outside the Result message"
                                    assert groups[current_group_name].info_label is None, \
                                        f'Duplicate info label for group "{current_group_name}"'
                                    groups[current_group_name].info_label = g.group(2)
                                elif kind == "Image":
                                    assert inside_message == "Result", "string type appears outside the Result message"
                                    assert groups[current_group_name].image is None, \
                                        f'Duplicate image for group "{current_group_name}"'
                                    groups[current_group_name].image = g.group(2)
                                else:
                                    # Process primitive types
                                    if kind == "int32" or kind == "int64":
                                        kind = "Int"
                                    elif kind == "double" or kind == "float":
                                        kind = "Double"
                                    groups[current_group_name].params.append(
                                        Param(kind=kind, name=g.group(2), label=g.group(3)))
                            else:
                                raise ValueError(f'Line "{line}" has incorrect structure')

    return groups.values()


print_line_prefix = ""


def print_line(s: str = ""):
    print(print_line_prefix, s, sep="")


def generate_ui_creation_code(groups: [Group]) -> [(str, str)]:
    global print_line_prefix

    pointers = []

    print_line_prefix = "    "
    print_line("explicit PhaseController(QScrollArea *area, QVBoxLayout *areaLayout) {")
    print_line()

    print_line_prefix = "        "
    for group in groups:
        print_line(f"// GROUP {group.name}")

        # Group container
        group_obj = f"group{group.name}"
        pointers.append(("QGroupBox", group_obj))
        print_line(f'{group_obj} = new QGroupBox(area);')
        print_line(f'{group_obj}->setTitle(QString::fromUtf8("{group.name}"));')

        # Horizontal layout of the group container
        h_layout_obj = f'hLayout{group.name}'
        pointers.append(("QHBoxLayout", h_layout_obj))
        print_line(f'{h_layout_obj} = new QHBoxLayout({group_obj});')

        # Left-side container
        left_container_obj = f'leftContainer{group.name}'
        pointers.append(("QWidget", left_container_obj))
        print_line(f'{left_container_obj} = new QWidget({group_obj});')
        print_line(f'{h_layout_obj}->addWidget({left_container_obj});')

        # Grid layout for the left-side container
        g_layout_obj = f'gLayout{group.name}'
        pointers.append(("QGridLayout", g_layout_obj))
        print_line(f'{g_layout_obj} = new QGridLayout({left_container_obj});')
        print_line(f'{g_layout_obj}->setContentsMargins(0, 0, 0, 0);')

        # Add parameter widgets
        row_count = 0
        for param in group.params:

            type_str = param.kind

            # Add checkbox or label
            if type_str.startswith("Toggled"):
                type_str = type_str[len("Toggled"):]  # consume the prefix

                # Checkbox
                label_obj = f'{param.name}Check'
                pointers.append(("QCheckBox", label_obj))
                print_line(f'{label_obj} = new QCheckBox({left_container_obj});')

            else:
                # Label
                label_obj = f'{param.name}Label'
                pointers.append(("QLabel", label_obj))
                print_line(f'{label_obj} = new QLabel({left_container_obj});')

            print_line(f'{label_obj}->setText(QString::fromUtf8("{param.label}"));')
            print_line(f'{g_layout_obj}->addWidget({label_obj}, {row_count}, 0, 1, 1);')  # span column 0

            # Get data type
            if type_str == "Enum":
                combo_obj = f'{param.name}Combo'
                pointers.append(("QComboBox", combo_obj))
                print_line(f'{combo_obj} = new QComboBox({left_container_obj});')
                for option in param.options:
                    print_line(f'{combo_obj}->addItem(QString::fromUtf8("{option}"));')
                print_line(f'{g_layout_obj}->addWidget({combo_obj}, {row_count}, 1, 1, 2);')  # span column 1-2

            else:  # not Enum, numerical types
                if type_str.startswith("Int"):
                    decimal = "0"
                    type_str = type_str[len("Int"):]  # consume the prefix
                elif type_str.startswith("Double"):
                    decimal = "2"
                    type_str = type_str[len("Double"):]  # consume the prefix
                else:
                    raise ValueError(f'Unknown data type prefix in "{type_str}"')

                # Add one or two spin boxes
                if len(type_str) == 0:
                    # No keyword "Range", single spin box
                    spin_obj = f'{param.name}Spin'
                    pointers.append(("QDoubleSpinBox", spin_obj))
                    print_line(f'{spin_obj} = new QDoubleSpinBox({left_container_obj});')
                    print_line(f'{spin_obj}->setDecimals({decimal});')
                    print_line(f'{spin_obj}->setMaximum(999);')
                    print_line(f'{g_layout_obj}->addWidget({spin_obj}, {row_count}, 1, 1, 1);')  # span column 1
                elif type_str == "Range":
                    # Two spin boxes
                    min_spin_obj = f'{param.name}MinSpin'
                    pointers.append(("QDoubleSpinBox", min_spin_obj))
                    print_line(f'{min_spin_obj} = new QDoubleSpinBox({left_container_obj});')
                    print_line(f'{min_spin_obj}->setDecimals({decimal});')
                    print_line(f'{min_spin_obj}->setMaximum(999);')
                    print_line(f'{g_layout_obj}->addWidget({min_spin_obj}, {row_count}, 1, 1, 1);')  # span column 1
                    max_spin_obj = f'{param.name}MaxSpin'
                    pointers.append(("QDoubleSpinBox", max_spin_obj))
                    print_line(f'{max_spin_obj} = new QDoubleSpinBox({left_container_obj});')
                    print_line(f'{max_spin_obj}->setDecimals({decimal});')
                    print_line(f'{max_spin_obj}->setMaximum(999);')
                    print_line(f'{g_layout_obj}->addWidget({max_spin_obj}, {row_count}, 2, 1, 1);')  # span column 2
                else:
                    raise ValueError(f'Unknown param type "{type_str}"')

            row_count += 1
            # Move to next param

        # Add vertical spacer
        v_spacer_obj = f'{group.name}VSpacer'
        pointers.append(("QSpacerItem", v_spacer_obj))
        print_line(f'{v_spacer_obj} = new QSpacerItem(229, 89, QSizePolicy::Minimum, QSizePolicy::Expanding);')
        print_line(f'{g_layout_obj}->addItem({v_spacer_obj}, {row_count}, 0, 1, 3);')  # span column 0 to 2
        row_count += 1

        # Add info label if required
        if group.info_label is not None:
            info_obj = f'{group.info_label}Label'
            pointers.append(("QLabel", info_obj))
            print_line(f'{info_obj} = new QLabel({left_container_obj});')
            print_line(f'{info_obj}->setText(QString::fromUtf8("{group.info_label}"));')
            print_line(f'{g_layout_obj}->addWidget({info_obj}, {row_count}, 0, 1, 3);')  # span column 0 to 2
            row_count += 1

        # Finish the left part
        # Add the horizontal spacer of the group
        h_spacer_obj = f'{group.name}HSpacer'
        pointers.append(("QSpacerItem", h_spacer_obj))
        print_line(f'{h_spacer_obj} = new QSpacerItem(446, 20, QSizePolicy::Expanding, QSizePolicy::Minimum);')
        print_line(f'{h_layout_obj}->addItem({h_spacer_obj});')

        # Add the image label if required
        if group.image is not None:
            image_obj = f'{group.image}Label'
            pointers.append(("QLabel", image_obj))
            print_line(f'{image_obj} = new QLabel({group_obj});')
            print_line(f'{image_obj}->setMinimumSize(QSize(0, 360));')
            print_line(f'{image_obj}->setMaximumSize(QSize(16777215, 360));')
            print_line(f'{image_obj}->setAlignment(Qt::AlignCenter);')
            print_line(f'{image_obj}->setText(QString::fromUtf8("{group.image}"));')
            print_line(f'{h_layout_obj}->addWidget({image_obj});')

        print_line(f'areaLayout->addWidget({group_obj});')
        print_line()
        # Move to next group

    print_line_prefix = "    "
    print_line("}")
    print_line()
    return pointers


def generate_apply_results_code(groups: [Group]) -> None:
    global print_line_prefix

    print_line_prefix = "    "
    print_line("void applyResults(const package::Result &results) {")

    print_line_prefix = "        "
    print_line()
    for group in groups:

        print_line(f"// GROUP {group.name}")

        # Set the info label
        if group.info_label is not None:
            info_obj = f'{group.info_label}Label'
            print_line('if (results.has_%s()) {' % group.info_label)
            print_line_prefix = "            "
            print_line(f'{info_obj}->setText(QString::fromStdString(results.{group.info_label}()));')
            print_line_prefix = "        "
            print_line('}')

        # Set the image label
        if group.image is not None:
            image_obj = f'{group.image}Label'
            print_line('if (results.has_%s()) {' % group.image)
            print_line_prefix = "            "
            print_line('QPixmap pixmap;')
            print_line(f'pixmap.loadFromData((const uint8_t *) results.{group.image}().data().c_str(), results.{group.image}().data().size());')
            print_line(f'{image_obj}->setPixmap(pixmap);')
            print_line_prefix = "        "
            print_line('}')

    print_line_prefix = "    "
    print_line("}")
    print_line()


def generate_member_variables(pointers: [(str, str)]) -> None:
    global print_line_prefix
    print_line_prefix = "    "
    for kind, field in pointers:
        print_line(f'{kind} *{field};')


def generate_all(proto_file: str) -> None:
    groups = parse_groups(proto_file)

    print(HEAD)
    pointers = generate_ui_creation_code(groups)
    generate_apply_results_code(groups)
    print("private:")
    print()
    generate_member_variables(pointers)
    print(TAIL)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("proto", help="Input proto file")
    args = parser.parse_args()
    generate_all(args.proto)
